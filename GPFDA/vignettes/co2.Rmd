---
title: "co2 data example"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{co2}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
        echo = TRUE, results = 'hold', warning=F, cache=F, 
  #dev = 'pdf', 
  message=F, 
  fig.width=5, fig.height=5,
  tidy.opts=list(width.cutoff=75), tidy=FALSE
)
options(scipen = 1, digits = 4)
```

```{r setup}
library(GPFDA)
```

## Loading co2 data
```{r}
data(co2, package = "GPFDA")
```


```{r}
# store data into matrix and remove missing values
y=data.matrix(co2[,!names(co2)%in%'Annual_Average'])
y=matrix(t(y),ncol=1)
x=1:612/12; x[y<0]=NA
mat=cbind(y,x)
mat=na.omit(mat)

X=as.matrix(mat[,2])
Y=as.matrix(mat[,1])
x=as.matrix(seq(1,612,len=1000)/12)
```

### Using powered exponential covariance kernel
```{r, message=F}
# First covariance matrix
system.time(a1 <- gpr(as.matrix(X),as.matrix(Y),'pow.ex', gamma=2, meanModel='t',
                      nInitCandidates=50, trace=2))
system.time(b1 <- gppredict(a1, input.new=as.matrix(x)))
```


```{r}
# plot(a1)
# plot(b1)
upper=b1$pred.mean+1.96*b1$pred.sd;
lower=b1$pred.mean-1.96*b1$pred.sd;
plot(-100,-100,col=0,xlim=range(X,x),ylim=range(upper,lower,Y),
     main="Prediction by powered exponential", xlab="input ",ylab="response")
polygon(c(x, rev(x)), c(upper, rev(lower)),col = "grey", border = NA)
points(X,Y,pch=2,col=2,cex=0.1)
# lines(X[,1],Y)
lines(x,b1$pred.mean,col=4,lwd=0.8)
```


### Using rational quadratic covariance kernel

```{r, message=F}
a2 <- gpr(as.matrix(X),as.matrix(Y),'rat.qu',meanModel='t',
          nInitCandidates=50, trace=2)
b2 <- gppredict(a2, input.new=as.matrix(x))
```


```{r}
# plot(a2)
# plot(b2)

upper=b2$pred.mean+1.96*b2$pred.sd;
lower=b2$pred.mean-1.96*b2$pred.sd;
plot(-100,-100,col=0,xlim=range(X,x),ylim=range(upper,lower,Y),
     main="Prediction by rational quadratic", xlab="input ",ylab="response")
polygon(c(x, rev(x)), c(upper, rev(lower)),col = "grey", border = NA)
points(X,Y,pch=2,col=2,cex=0.1)
# lines(X[,1],Y)
lines(x,b2$pred.mean,col=4,lwd=0.8)
```


### Defining a customized covariance kernel

```{r}
cov.custom=function(hyper,input,input.new=NULL){
  hyper=lapply(hyper,exp);
  datadim=dim(input)
  if(is.null(input.new)) input.new=input
  A1 <- GPFDA:::DistMat(X=input, Xnew = input.new, A=as.matrix(hyper$custom.w), 
                        power=2)
  mdim=dim(input);mdim.new=dim(input.new)
  cov.=sapply(1:mdim[1],function(i) matrix(rep(input[i,],mdim.new[1]),
                                           nrow=mdim.new[1],byrow=T)-input.new)
  cov..=matrix(0,ncol=mdim[1],nrow=mdim.new[1])
  if(mdim[2]>1){
    for(i in 1:(mdim[2]-1)){
      cov..=cov..+cov.[1:mdim.new[1],];cov.=cov.[-(1:mdim.new[1]),]}
    cov.=cov..+cov.   # x-x'
  }
  A2=t(hyper$custom.u*(sin(pi*cov.))^2)
  return(hyper$custom.v*exp(-A1-A2))
}

# Define the first derivative of the customized covariance matrix 
Dloglik.custom.w=function(hyper,input,AlphaQ){
  Dcov=cov.custom(hyper,input)
  A1 <- -GPFDA:::DistMat_sq(X=input, A=as.matrix(hyper$custom.w), power=2)
  out=Dcov %*% A1
  out=sum(out*AlphaQ)
  return(out)
}

Dloglik.custom.u=function(hyper,input,AlphaQ){
  Dcov=cov.custom(hyper,input)
  hyper=lapply(hyper,exp)
  mdim=dim(input);mdim.new=mdim
  cov.=sapply(1:mdim[1],function(i) matrix(rep(input[i,],mdim.new[1]),
                                           nrow=mdim.new[1],byrow=T)-input)
  cov..=matrix(0,ncol=mdim[1],nrow=mdim.new[1])
  if(mdim[2]>1){
    for(i in 1:(mdim[2]-1)){
      cov..=cov..+cov.[1:mdim.new[1],];cov.=cov.[-(1:mdim.new[1]),]}
    cov.=cov..+cov.
  }
  A2=-hyper$custom.u*(sin(pi*cov.))^2 
  out=Dcov%*%A2
  out=sum(out*AlphaQ)
  return(out)
}

Dloglik.custom.v=function(hyper,input,AlphaQ){
  out=cov.custom(hyper,input)
  out=sum(out*AlphaQ)
  return(out)
}

# Define the second derivative of the customized covariance matrix 
D2custom.w=function(hyper,input,inv.Q,Alpha.Q){
  Dcov=cov.custom(hyper,input)
  A1 <- -GPFDA:::DistMat_sq(X=input, A=as.matrix(hyper$custom.w), power=2)
  wD2=Dcov%*%(A1^2+A1)
  wD1=Dcov%*%A1
  D2c.w=D2(wD1,wD2,inv.Q,Alpha.Q)
  return(D2c.w)
}

D2custom.w=function(hyper,input,inv.Q,Alpha.Q){
  Dcov=cov.custom(hyper,input)
  A1 <- -GPFDA:::DistMat_sq(X=input, A=as.matrix(hyper$custom.w), power=2)
  wD2=Dcov%*%(A1^2+A1)
  wD1=Dcov%*%A1
  D2c.w=D2(wD1,wD2,inv.Q,Alpha.Q)
  return(D2c.w)
}


D2custom.u=function(hyper,input,inv.Q,Alpha.Q){
  Dcov=cov.custom(hyper,input)
  hyper=lapply(hyper,exp)
  mdim=dim(input);mdim.new=mdim
  cov.=sapply(1:mdim[1],function(i) matrix(rep(input[i,],mdim.new[1]),
                                           nrow=mdim.new[1],byrow=T)-input)
  cov..=matrix(0,ncol=mdim[1],nrow=mdim.new[1])
  if(mdim[2]>1){
    for(i in 1:(mdim[2]-1)){
      cov..=cov..+cov.[1:mdim.new[1],];cov.=cov.[-(1:mdim.new[1]),]}
    cov.=cov..+cov.
  }
  A2=-hyper$custom.u*(sin(pi*cov.))^2  
  uD2=Dcov%*%(A2^2+A2)
  uD1=Dcov%*%A2
  D2c.u=D2(uD1,uD2,inv.Q,Alpha.Q)
  return(D2c.u)
}

D2custom.v=function(hyper,input,inv.Q,Alpha.Q){
  vD1=cov.custom(hyper,input)
  vD2=vD1
  D2c.v=D2(vD1,vD2,inv.Q,Alpha.Q)
  return(D2c.v)
}

# Define the diagonal of the customized covariance matrix 
diag.custom=function(hyper,input){
  Qstar=rep(exp(hyper$custom.v),dim(input)[1])
  return(Qstar)
}
```

### Using the three covariance functions 
```{r, message=F}
# Use all three covariance kernels
a3 <- gpr(as.matrix(X),as.matrix(Y),Cov=c('pow.ex','custom','rat.qu'),
		NewHyper=c('custom.w','custom.u','custom.v'), gamma=2, meanModel='t',
		nInitCandidates=50, trace=2)
b3 <- gppredict(a3, input.new=as.matrix(x))
```


```{r}
# plot(a3)    
# plot(b3)
upper=b3$pred.mean+1.96*b3$pred.sd;
lower=b3$pred.mean-1.96*b3$pred.sd;
plot(-100,-100,col=0,xlim=range(X,x),ylim=range(upper,lower,Y),
     main="Prediction by sum of three kernels", xlab="input ",ylab="response")
polygon(c(x, rev(x)), c(upper, rev(lower)),col = "grey", border = NA)
points(X,Y,pch=2,col=2,cex=0.1)
# lines(X[,1],Y)
lines(x,b3$pred.mean,col=4,lwd=0.8)
```

