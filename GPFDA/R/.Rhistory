data(co2)
data_co2=co2
# store data into matrix and remove missing values
y=data.matrix(data_co2[,!names(data_co2)%in%'Annual_Average'])
y=matrix(t(y),ncol=1)
x=1:612/12; x[y<0]=NA
mat=cbind(y,x)
mat=na.omit(mat)
X=as.matrix(mat[,2])
Y=as.matrix(mat[,1])
x=as.matrix(seq(1,612,len=1000)/12)
# First covariance matrix
system.time(a1 <- gpr(as.matrix(X),as.matrix(Y),c('pow.ex'),mean='t',trace=2))
system.time(b1 <- gppredict(a1,Data.new=as.matrix(x)))
# plot(a1)
# plot(b1)
upper=b1$pred.mean+1.96*b1$pred.sd;
lower=b1$pred.mean-1.96*b1$pred.sd;
plot(-100,-100,col=0,xlim=range(X,x),ylim=range(upper,lower,Y),main="Prediction by powered exponential", xlab="input ",ylab="response")
polygon(c(x, rev(x)), c(upper, rev(lower)),col = "grey", border = NA)
points(X,Y,pch=2,col=2,cex=0.1)
# lines(X[,1],Y)
lines(x,b1$pred.mean,col=4,lwd=0.8)
# Second covariance matrix
a2 <- gpr(as.matrix(X),as.matrix(Y),c('rat.qu'),mean='t',trace=2)
b2 <- gppredict(a2,Data.new=as.matrix(x))
# plot(a2)
# plot(b2)
upper=b2$pred.mean+1.96*b2$pred.sd;
lower=b2$pred.mean-1.96*b2$pred.sd;
plot(-100,-100,col=0,xlim=range(X,x),ylim=range(upper,lower,Y),main="Prediction by rational quadratic", xlab="input ",ylab="response")
polygon(c(x, rev(x)), c(upper, rev(lower)),col = "grey", border = NA)
points(X,Y,pch=2,col=2,cex=0.1)
# lines(X[,1],Y)
lines(x,b2$pred.mean,col=4,lwd=0.8)
## Define the customized covariance matrix
cov.custom=function(hyper,Data,Data.new=NULL){
hyper=lapply(hyper,exp);
datadim=dim(Data)
if(is.null(Data.new)) Data.new=Data
A1=xixj_sta(Data,Data.new,hyper$custom.w) #exp(w)*||x-x'||^2
mdim=dim(Data);mdim.new=dim(Data.new)
cov.=sapply(1:mdim[1],function(i) matrix(rep(Data[i,],mdim.new[1]),nrow=mdim.new[1],byrow=T)-Data.new)
cov..=matrix(0,ncol=mdim[1],nrow=mdim.new[1])
if(mdim[2]>1){
for(i in 1:(mdim[2]-1)){
cov..=cov..+cov.[1:mdim.new[1],];cov.=cov.[-(1:mdim.new[1]),]}
cov.=cov..+cov.   # x-x'
}
A2=hyper$custom.u*(sin(pi*cov.))^2
return(hyper$custom.v*exp(-A1-A2))
}
# Define the first derivative of the customized covariance matrix
DCov.custom.w=function(hyper,data,AlphaQ){
Dcov=cov.custom(hyper,data)
A1=-xixj_sta(data,data,hyper$custom.w)
out=Dcov %*% A1
out=sum(out*AlphaQ)
return(out)
}
DCov.custom.u=function(hyper,data,AlphaQ){
Dcov=cov.custom(hyper,data)
hyper=lapply(hyper,exp)
mdim=dim(data);mdim.new=mdim
cov.=sapply(1:mdim[1],function(i) matrix(rep(data[i,],mdim.new[1]),nrow=mdim.new[1],byrow=T)-data)
cov..=matrix(0,ncol=mdim[1],nrow=mdim.new[1])
if(mdim[2]>1){
for(i in 1:(mdim[2]-1)){
cov..=cov..+cov.[1:mdim.new[1],];cov.=cov.[-(1:mdim.new[1]),]}
cov.=cov..+cov.
}
A2=-hyper$custom.u*(sin(pi*cov.))^2
out=Dcov%*%A2
out=sum(out*AlphaQ)
return(out)
}
DCov.custom.v=function(hyper,data,AlphaQ){
out=cov.custom(hyper,data)
out=sum(out*AlphaQ)
return(out)
}
# Define the second derivative of the customized covariance matrix
D2custom.w=function(hyper,data,inv.Q,Alpha.Q){
Dcov=cov.custom(hyper,data)
A1=-xixj_sta(data,data,hyper$custom.w)
wD2=Dcov%*%(A1^2+A1)
wD1=Dcov%*%A1
D2c.w=D2(wD1,wD2,inv.Q,Alpha.Q)
return(D2c.w)
}
D2custom.w=function(hyper,data,inv.Q,Alpha.Q){
Dcov=cov.custom(hyper,data)
A1=-xixj_sta(data,data,hyper$custom.w)
wD2=Dcov%*%(A1^2+A1)
wD1=Dcov%*%A1
D2c.w=D2(wD1,wD2,inv.Q,Alpha.Q)
return(D2c.w)
}
D2custom.u=function(hyper,data,inv.Q,Alpha.Q){
Dcov=cov.custom(hyper,data)
hyper=lapply(hyper,exp)
mdim=dim(data);mdim.new=mdim
cov.=sapply(1:mdim[1],function(i) matrix(rep(data[i,],mdim.new[1]),nrow=mdim.new[1],byrow=T)-data)
cov..=matrix(0,ncol=mdim[1],nrow=mdim.new[1])
if(mdim[2]>1){
for(i in 1:(mdim[2]-1)){
cov..=cov..+cov.[1:mdim.new[1],];cov.=cov.[-(1:mdim.new[1]),]}
cov.=cov..+cov.
}
A2=-hyper$custom.u*(sin(pi*cov.))^2
uD2=Dcov%*%(A2^2+A2)
uD1=Dcov%*%A2
D2c.u=D2(uD1,uD2,inv.Q,Alpha.Q)
return(D2c.u)
}
D2custom.v=function(hyper,data,inv.Q,Alpha.Q){
vD1=cov.custom(hyper,data)
vD2=vD1
D2c.v=D2(vD1,vD2,inv.Q,Alpha.Q)
return(D2c.v)
}
# Define the diagonal of the customized covariance matrix
diag.custom=function(hyper,data){
Qstar=rep(exp(hyper$custom.v),dim(data)[1])
return(Qstar)
}
# Use all three covariance matrix
a3 <- gpr(as.matrix(X),as.matrix(Y),Cov=c('pow.ex','custom','rat.qu'),
NewHyper=c('custom.w','custom.u','custom.v'),mean='t',trace=2)
b3 <- gppredict(a3,Data.new=as.matrix(x))
plot(b3)
str(Y)
summary(Y)
rm(list = ls())
library(GPFDA)
# load data
data(co2)
data_co2=co2
# store data into matrix and remove missing values
y=data.matrix(data_co2[,!names(data_co2)%in%'Annual_Average'])
y=matrix(t(y),ncol=1)
x=1:612/12; x[y<0]=NA
mat=cbind(y,x)
mat=na.omit(mat)
X=as.matrix(mat[,2])
Y=as.matrix(mat[,1])
x=as.matrix(seq(1,612,len=1000)/12)
# First covariance matrix
system.time(a1 <- gpr(as.matrix(X),as.matrix(Y),c('pow.ex'),mean='t',trace=2))
system.time(b1 <- gppredict(a1,Data.new=as.matrix(x)))
# plot(a1)
# plot(b1)
upper=b1$pred.mean+1.96*b1$pred.sd;
lower=b1$pred.mean-1.96*b1$pred.sd;
plot(-100,-100,col=0,xlim=range(X,x),ylim=range(upper,lower,Y),main="Prediction by powered exponential", xlab="input ",ylab="response")
polygon(c(x, rev(x)), c(upper, rev(lower)),col = "grey", border = NA)
points(X,Y,pch=2,col=2,cex=0.1)
# lines(X[,1],Y)
lines(x,b1$pred.mean,col=4,lwd=0.8)
data(co2)
data_co2=co2
# store data into matrix and remove missing values
y=data.matrix(data_co2[,!names(data_co2)%in%'Annual_Average'])
y=matrix(t(y),ncol=1)
x=1:612/12; x[y<0]=NA
mat=cbind(y,x)
mat=na.omit(mat)
X=as.matrix(mat[,2])
Y=as.matrix(mat[,1])
x=as.matrix(seq(1,612,len=1000)/12)
# First covariance matrix
system.time(a1 <- gpr(as.matrix(X),as.matrix(Y),c('pow.ex'),mean='t',trace=2))
system.time(b1 <- gppredict(a1,Data.new=as.matrix(x)))
# plot(a1)
# plot(b1)
upper=b1$pred.mean+1.96*b1$pred.sd;
lower=b1$pred.mean-1.96*b1$pred.sd;
plot(-100,-100,col=0,xlim=range(X,x),ylim=range(upper,lower,Y),main="Prediction by powered exponential", xlab="input ",ylab="response")
polygon(c(x, rev(x)), c(upper, rev(lower)),col = "grey", border = NA)
points(X,Y,pch=2,col=2,cex=0.1)
# lines(X[,1],Y)
lines(x,b1$pred.mean,col=4,lwd=0.8)
gpr=function(Data, response, Cov=c('linear','pow.ex'), hyper=NULL, NewHyper=NULL, mean=0, gamma=1,itermax=100,reltol=8e-10,trace=0){#,Xprior,Xprior2){
#   set.seed(60);
Data=as.matrix(Data)
y.original=response
response=as.matrix(response)
if(is.null(hyper)){
hyper=list()
if(any(Cov=='linear'))
#  hyper$linear.a=rep(log(0.01),dim(Data)[2])
hyper$linear.a=rnorm(dim(Data)[2],sd=0.01)
if(any(Cov=='pow.ex')){
#  hyper$pow.ex.v=log(1)
#  hyper$pow.ex.w=rep(log(10),dim(Data)[2])
hyper$pow.ex.v=rnorm(1,sd=0.01)
hyper$pow.ex.w=-(abs(rnorm(dim(Data)[2],sd=0.01)))
}
if(any(Cov=='rat.qu')){
#  hyper$rat.qu.w=rep(log(1),dim(Data)[2])
#  hyper$rat.qu.s=log(1.5)
#  hyper$rat.qu.a=log(1.5)
hyper$rat.qu.w=abs(rnorm(dim(Data)[2],sd=0.01))
hyper$rat.qu.s=runif(1,0.01,0.5)
hyper$rat.qu.a=runif(1,0.01,0.5)
}
hyper$vv=sample(x=c(0.2,0.5,1,1.5),1)
hyper.nam=names(hyper)
if(!is.null(NewHyper)){
hyper.nam=c(hyper.nam,NewHyper)
nh.length=length(NewHyper)
for(i in 1:nh.length){
hyper=c(hyper,runif(1,-1,1))
}
names(hyper)=hyper.nam
}
}
if(!is.null(hyper)){
hyper=hyper[substr(names(hyper),1,6)%in%c(Cov,'vv')]
}
hp.name=names(unlist(hyper))
if(mean==0) {response=response; mean=0;lrm=0}
if(mean==1) {mean=mean(response);response=as.matrix(response-mean);lrm=1}
if(mean=='t') {
trend=data.frame(yyy=response,xxx=Data[,1])
lrm=lm(yyy~xxx,data=trend);
response=as.matrix(resid(lrm));
mean=fitted(lrm)
}
trace=round(trace)
if(trace>0)
cat(c('\n','title: -likelihood:',hp.name,'\n'),sep='     ')
CG0 <- nlminb(unlist(hyper), gp.loglikelihood2, gp.Dlikelihood2,Data=Data,response=response,Cov=Cov,gamma=gamma,control=list(iter.max=itermax,rel.tol=reltol,trace=trace))
# CG0 <- optim(unlist(hyper), gp.loglikelihood2, gp.Dlikelihood2,Data=Data,response=response,Cov=Cov,gamma=gamma,method='CG',control=list(maxiter=itermax,reltol=reltol,trace=trace))
# if(trace!=F&CG0$convergence==0)
#   cat('\n','    optimization finished. Converged.','\n')
# if(trace!=F&CG0$convergence==1)
#   cat('\n','    optimization finished. Failed Converge.','\n')
if(trace>0)
cat('\n','    optimization finished.','\n')
CG=CG0[[1]]
names(CG)=hp.name
CG.df=data.frame(CG=CG,CG.N=substr(hp.name,1,8))
names(CG.df)=c('CG','CG.N')
hyper.cg=split(CG.df$CG,CG.df$CG.N)
n=length(Cov)
CovList=vector('list',n)
for(i in 1:n) CovList[i]=list(paste0('cov.',Cov[i]))
CovL=lapply(CovList,function(j){
f=get(j)
if(j=='cov.pow.ex')
return(f(hyper.cg,Data,Data,gamma=gamma))
if(j!='cov.pow.ex')
return(f(hyper.cg,Data,Data))
}  )
if(length(CovL)==1)
Q=CovL[[1]]
if(length(CovL)>1)
Q=Reduce('+',CovL)
response=as.matrix(response)
# Q=Q+diag(exp(hyper.cg$vv),dim(Q)[1])
diag(Q)=diag(Q)+exp(hyper.cg$vv)
# invQ=pseudoinverse(Q+diag(1e-9,ncol=ncol(Q),nrow=nrow(Q)))
# invQ=pseudoinverse(Q)
invQ=mymatrix2(Q)$res
QR=invQ%*%response
AlphaQ=QR%*%t(QR)-invQ
D2fx=lapply(seq_along(hyper.cg),function(i){
Dp=hyper.cg[i]
name.Dp=names(Dp)
f=get(paste0('D2',name.Dp))
if(name.Dp%in%c('pow.ex.w','pow.ex.v') )
D2para=f(hyper.cg,Data,gamma=gamma,inv.Q=invQ,Alpha.Q=AlphaQ)
if(!name.Dp%in%c('pow.ex.w','pow.ex.v'))
D2para=f(hyper.cg,Data,inv.Q=invQ,Alpha.Q=AlphaQ)
return(D2para)
})
names(D2fx)=names(hyper.cg)
II=(-1/(unlist(D2fx)*dim(Data)[1]))
fitted=(Q-diag(exp(hyper.cg$vv),dim(Q)[1]))%*%invQ%*%(response)+mean
fitted.var=exp(hyper.cg$vv)*rowSums((Q-diag(exp(hyper.cg$vv),dim(Q)[1]))*t(invQ))
result=list('hyper'=hyper.cg,'I'=II,'fitted.mean'=fitted[,1],fitted.sd=sqrt(fitted.var),'train.x'=Data,'train.y'=response,'train.yOri'=y.original, 'CovFun'=Cov,'gamma'=gamma,'Q'=Q,'inv'=invQ,'mean'=mean,'lrm'=lrm,conv=CG0$convergence,'hyper0'=hyper)
class(result)='gpr'
return(result)
}
gpr=function(Data, response, Cov=c('linear','pow.ex'), hyper=NULL, NewHyper=NULL, mean=0, gamma=1,itermax=100,reltol=8e-10,trace=0){#,Xprior,Xprior2){
#   set.seed(60);
Data=as.matrix(Data)
y.original=response
response=as.matrix(response)
if(is.null(hyper)){
hyper=list()
if(any(Cov=='linear'))
#  hyper$linear.a=rep(log(0.01),dim(Data)[2])
hyper$linear.a=rnorm(dim(Data)[2],sd=0.01)
if(any(Cov=='pow.ex')){
#  hyper$pow.ex.v=log(1)
#  hyper$pow.ex.w=rep(log(10),dim(Data)[2])
hyper$pow.ex.v=rnorm(1,sd=0.01)
hyper$pow.ex.w=-(abs(rnorm(dim(Data)[2],sd=0.01)))
}
if(any(Cov=='rat.qu')){
#  hyper$rat.qu.w=rep(log(1),dim(Data)[2])
#  hyper$rat.qu.s=log(1.5)
#  hyper$rat.qu.a=log(1.5)
hyper$rat.qu.w=abs(rnorm(dim(Data)[2],sd=0.01))
hyper$rat.qu.s=runif(1,0.01,0.5)
hyper$rat.qu.a=runif(1,0.01,0.5)
}
hyper$vv=sample(x=c(-3),1)
hyper.nam=names(hyper)
if(!is.null(NewHyper)){
hyper.nam=c(hyper.nam,NewHyper)
nh.length=length(NewHyper)
for(i in 1:nh.length){
hyper=c(hyper,runif(1,-1,1))
}
names(hyper)=hyper.nam
}
}
if(!is.null(hyper)){
hyper=hyper[substr(names(hyper),1,6)%in%c(Cov,'vv')]
}
hp.name=names(unlist(hyper))
if(mean==0) {response=response; mean=0;lrm=0}
if(mean==1) {mean=mean(response);response=as.matrix(response-mean);lrm=1}
if(mean=='t') {
trend=data.frame(yyy=response,xxx=Data[,1])
lrm=lm(yyy~xxx,data=trend);
response=as.matrix(resid(lrm));
mean=fitted(lrm)
}
trace=round(trace)
if(trace>0)
cat(c('\n','title: -likelihood:',hp.name,'\n'),sep='     ')
CG0 <- nlminb(unlist(hyper), gp.loglikelihood2, gp.Dlikelihood2,Data=Data,response=response,Cov=Cov,gamma=gamma,control=list(iter.max=itermax,rel.tol=reltol,trace=trace))
# CG0 <- optim(unlist(hyper), gp.loglikelihood2, gp.Dlikelihood2,Data=Data,response=response,Cov=Cov,gamma=gamma,method='CG',control=list(maxiter=itermax,reltol=reltol,trace=trace))
# if(trace!=F&CG0$convergence==0)
#   cat('\n','    optimization finished. Converged.','\n')
# if(trace!=F&CG0$convergence==1)
#   cat('\n','    optimization finished. Failed Converge.','\n')
if(trace>0)
cat('\n','    optimization finished.','\n')
CG=CG0[[1]]
names(CG)=hp.name
CG.df=data.frame(CG=CG,CG.N=substr(hp.name,1,8))
names(CG.df)=c('CG','CG.N')
hyper.cg=split(CG.df$CG,CG.df$CG.N)
n=length(Cov)
CovList=vector('list',n)
for(i in 1:n) CovList[i]=list(paste0('cov.',Cov[i]))
CovL=lapply(CovList,function(j){
f=get(j)
if(j=='cov.pow.ex')
return(f(hyper.cg,Data,Data,gamma=gamma))
if(j!='cov.pow.ex')
return(f(hyper.cg,Data,Data))
}  )
if(length(CovL)==1)
Q=CovL[[1]]
if(length(CovL)>1)
Q=Reduce('+',CovL)
response=as.matrix(response)
# Q=Q+diag(exp(hyper.cg$vv),dim(Q)[1])
diag(Q)=diag(Q)+exp(hyper.cg$vv)
# invQ=pseudoinverse(Q+diag(1e-9,ncol=ncol(Q),nrow=nrow(Q)))
# invQ=pseudoinverse(Q)
invQ=mymatrix2(Q)$res
QR=invQ%*%response
AlphaQ=QR%*%t(QR)-invQ
D2fx=lapply(seq_along(hyper.cg),function(i){
Dp=hyper.cg[i]
name.Dp=names(Dp)
f=get(paste0('D2',name.Dp))
if(name.Dp%in%c('pow.ex.w','pow.ex.v') )
D2para=f(hyper.cg,Data,gamma=gamma,inv.Q=invQ,Alpha.Q=AlphaQ)
if(!name.Dp%in%c('pow.ex.w','pow.ex.v'))
D2para=f(hyper.cg,Data,inv.Q=invQ,Alpha.Q=AlphaQ)
return(D2para)
})
names(D2fx)=names(hyper.cg)
II=(-1/(unlist(D2fx)*dim(Data)[1]))
fitted=(Q-diag(exp(hyper.cg$vv),dim(Q)[1]))%*%invQ%*%(response)+mean
fitted.var=exp(hyper.cg$vv)*rowSums((Q-diag(exp(hyper.cg$vv),dim(Q)[1]))*t(invQ))
result=list('hyper'=hyper.cg,'I'=II,'fitted.mean'=fitted[,1],fitted.sd=sqrt(fitted.var),'train.x'=Data,'train.y'=response,'train.yOri'=y.original, 'CovFun'=Cov,'gamma'=gamma,'Q'=Q,'inv'=invQ,'mean'=mean,'lrm'=lrm,conv=CG0$convergence,'hyper0'=hyper)
class(result)='gpr'
return(result)
}
# First covariance matrix
system.time(a1 <- gpr(as.matrix(X),as.matrix(Y),c('pow.ex'),mean='t',trace=2))
GPFDA:::gpr=function(Data, response, Cov=c('linear','pow.ex'), hyper=NULL, NewHyper=NULL, mean=0, gamma=1,itermax=100,reltol=8e-10,trace=0){#,Xprior,Xprior2){
#   set.seed(60);
Data=as.matrix(Data)
y.original=response
response=as.matrix(response)
if(is.null(hyper)){
hyper=list()
if(any(Cov=='linear'))
#  hyper$linear.a=rep(log(0.01),dim(Data)[2])
hyper$linear.a=rnorm(dim(Data)[2],sd=0.01)
if(any(Cov=='pow.ex')){
#  hyper$pow.ex.v=log(1)
#  hyper$pow.ex.w=rep(log(10),dim(Data)[2])
hyper$pow.ex.v=rnorm(1,sd=0.01)
hyper$pow.ex.w=-(abs(rnorm(dim(Data)[2],sd=0.01)))
}
if(any(Cov=='rat.qu')){
#  hyper$rat.qu.w=rep(log(1),dim(Data)[2])
#  hyper$rat.qu.s=log(1.5)
#  hyper$rat.qu.a=log(1.5)
hyper$rat.qu.w=abs(rnorm(dim(Data)[2],sd=0.01))
hyper$rat.qu.s=runif(1,0.01,0.5)
hyper$rat.qu.a=runif(1,0.01,0.5)
}
hyper$vv=sample(x=c(-3),1)
hyper.nam=names(hyper)
if(!is.null(NewHyper)){
hyper.nam=c(hyper.nam,NewHyper)
nh.length=length(NewHyper)
for(i in 1:nh.length){
hyper=c(hyper,runif(1,-1,1))
}
names(hyper)=hyper.nam
}
}
if(!is.null(hyper)){
hyper=hyper[substr(names(hyper),1,6)%in%c(Cov,'vv')]
}
hp.name=names(unlist(hyper))
if(mean==0) {response=response; mean=0;lrm=0}
if(mean==1) {mean=mean(response);response=as.matrix(response-mean);lrm=1}
if(mean=='t') {
trend=data.frame(yyy=response,xxx=Data[,1])
lrm=lm(yyy~xxx,data=trend);
response=as.matrix(resid(lrm));
mean=fitted(lrm)
}
trace=round(trace)
if(trace>0)
cat(c('\n','title: -likelihood:',hp.name,'\n'),sep='     ')
CG0 <- nlminb(unlist(hyper), gp.loglikelihood2, gp.Dlikelihood2,Data=Data,response=response,Cov=Cov,gamma=gamma,control=list(iter.max=itermax,rel.tol=reltol,trace=trace))
# CG0 <- optim(unlist(hyper), gp.loglikelihood2, gp.Dlikelihood2,Data=Data,response=response,Cov=Cov,gamma=gamma,method='CG',control=list(maxiter=itermax,reltol=reltol,trace=trace))
# if(trace!=F&CG0$convergence==0)
#   cat('\n','    optimization finished. Converged.','\n')
# if(trace!=F&CG0$convergence==1)
#   cat('\n','    optimization finished. Failed Converge.','\n')
if(trace>0)
cat('\n','    optimization finished.','\n')
CG=CG0[[1]]
names(CG)=hp.name
CG.df=data.frame(CG=CG,CG.N=substr(hp.name,1,8))
names(CG.df)=c('CG','CG.N')
hyper.cg=split(CG.df$CG,CG.df$CG.N)
n=length(Cov)
CovList=vector('list',n)
for(i in 1:n) CovList[i]=list(paste0('cov.',Cov[i]))
CovL=lapply(CovList,function(j){
f=get(j)
if(j=='cov.pow.ex')
return(f(hyper.cg,Data,Data,gamma=gamma))
if(j!='cov.pow.ex')
return(f(hyper.cg,Data,Data))
}  )
if(length(CovL)==1)
Q=CovL[[1]]
if(length(CovL)>1)
Q=Reduce('+',CovL)
response=as.matrix(response)
# Q=Q+diag(exp(hyper.cg$vv),dim(Q)[1])
diag(Q)=diag(Q)+exp(hyper.cg$vv)
# invQ=pseudoinverse(Q+diag(1e-9,ncol=ncol(Q),nrow=nrow(Q)))
# invQ=pseudoinverse(Q)
invQ=mymatrix2(Q)$res
QR=invQ%*%response
AlphaQ=QR%*%t(QR)-invQ
D2fx=lapply(seq_along(hyper.cg),function(i){
Dp=hyper.cg[i]
name.Dp=names(Dp)
f=get(paste0('D2',name.Dp))
if(name.Dp%in%c('pow.ex.w','pow.ex.v') )
D2para=f(hyper.cg,Data,gamma=gamma,inv.Q=invQ,Alpha.Q=AlphaQ)
if(!name.Dp%in%c('pow.ex.w','pow.ex.v'))
D2para=f(hyper.cg,Data,inv.Q=invQ,Alpha.Q=AlphaQ)
return(D2para)
})
names(D2fx)=names(hyper.cg)
II=(-1/(unlist(D2fx)*dim(Data)[1]))
fitted=(Q-diag(exp(hyper.cg$vv),dim(Q)[1]))%*%invQ%*%(response)+mean
fitted.var=exp(hyper.cg$vv)*rowSums((Q-diag(exp(hyper.cg$vv),dim(Q)[1]))*t(invQ))
result=list('hyper'=hyper.cg,'I'=II,'fitted.mean'=fitted[,1],fitted.sd=sqrt(fitted.var),'train.x'=Data,'train.y'=response,'train.yOri'=y.original, 'CovFun'=Cov,'gamma'=gamma,'Q'=Q,'inv'=invQ,'mean'=mean,'lrm'=lrm,conv=CG0$convergence,'hyper0'=hyper)
class(result)='gpr'
return(result)
}
environment(gpr)
environment(gprpredict)
environment(gppredict)
environment(gpr) = namespace:GPFDA
environment(gpr) = "GPFDA"
environment(gpr) = environment(gppredict)
environment(gpr)
# First covariance matrix
system.time(a1 <- gpr(as.matrix(X),as.matrix(Y),c('pow.ex'),mean='t',trace=2))
system.time(b1 <- gppredict(a1,Data.new=as.matrix(x)))
# plot(a1)
# plot(b1)
upper=b1$pred.mean+1.96*b1$pred.sd;
lower=b1$pred.mean-1.96*b1$pred.sd;
plot(-100,-100,col=0,xlim=range(X,x),ylim=range(upper,lower,Y),main="Prediction by powered exponential", xlab="input ",ylab="response")
polygon(c(x, rev(x)), c(upper, rev(lower)),col = "grey", border = NA)
points(X,Y,pch=2,col=2,cex=0.1)
# lines(X[,1],Y)
lines(x,b1$pred.mean,col=4,lwd=0.8)
